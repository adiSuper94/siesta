package main
import (
  "fmt"
	"context"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/pgtype"
	"github.com/jackc/pgx/v5/pgconn"
)

type DBTX interface {
	Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
	Query(context.Context, string, ...interface{}) (pgx.Rows, error)
	QueryRow(context.Context, string, ...interface{}) pgx.Row
}

type option[T any] struct{
  value T
  isSome bool
}

func some[T any](value T) option[T] {
  return option[T]{isSome: true, value: value}
}

func none[T any]() option[T] {
  return option[T]{isSome: false}
}

func(o option[T]) get() T {
  if o.isSome {return o.value}
  panic("option is empty")
}

func (o option[T]) isEmpty() bool {
  return !o.isSome
}

{{ range $tableName, $table := .Tables }}
type {{ toCamelCase $table.TableName}} struct {
{{ range $table.Columns}} {{ toCamelCase .ColumnName }} option[{{ .GetGoType }}]
{{end}}
}

func SelectAll{{ toCamelCase $tableName }}(ctx context.Context, db DBTX) ([]{{ toCamelCase $tableName }}, error){
  var res []{{ toCamelCase $tableName }}
  query := "{{$table.SelectAllQuery}}"
	rows, err := db.Query(ctx, query)
  defer rows.Close()
  if err != nil{
    fmt.Printf("error while executing %v \n Error: %v\n", query, err)
    return res, err
  }
  for rows.Next(){
    {{ range $table.Columns}} var {{ toCamelCase .ColumnName }} {{ .GetGoType }}
    {{end}}
    rows.Scan({{range $table.Columns}}&{{ toCamelCase .ColumnName}},{{end}})
    row := {{toCamelCase $tableName}}{
      {{range $table.Columns}}{{ toCamelCase .ColumnName}}:some({{toCamelCase .ColumnName}}),{{end}}
    }
    res = append(res, row)
  }
  return res, nil
}

func Get{{toCamelCase $tableName}}ByPK(ctx context.Context, db DBTX, {{range $table.PK}}{{toLowerCamelCase .ColumnName}} {{.GetGoType}}, {{end}}) (*{{toCamelCase $tableName}}, error){
  query := "{{ $table.SelectByPKQuery }}"
  rawRow := db.QueryRow(ctx, query, {{range $table.PK}}{{ toLowerCamelCase .ColumnName}},{{end}})
  {{ range $table.Columns}} var {{ toCamelCase .ColumnName }} {{ .GetGoType }}
  {{end}}
  err:= rawRow.Scan({{range $table.Columns}}&{{ toCamelCase .ColumnName}},{{end}})
  if err != nil {
    fmt.Printf("error while selecting row from {{$tableName}} \n error: %v", err)
    return nil, err
  }
  row := {{toCamelCase $tableName}}{
    {{range $table.Columns}}{{ toCamelCase .ColumnName}}:some({{toCamelCase .ColumnName}}),{{end}}
  }
  return &row, nil
}

func Delete{{toCamelCase $tableName}}ByPK(ctx context.Context, db DBTX, {{range $table.PK}}{{toLowerCamelCase .ColumnName}} {{.GetGoType}}, {{end}}) (bool, error){
  query := "{{$table.DeleteQuery}}"
  _, err := db.Exec(ctx, query, {{range $table.PK}}{{toLowerCamelCase .ColumnName}}, {{end}})
  if err != nil {
    fmt.Printf("error while deleting row from {{$tableName}} \n error: %v", err)
    return false, err
  }
  return true, nil
}

func Insert{{toCamelCase $tableName}}(ctx context.Context, db DBTX, row {{toCamelCase $tableName}}) (*{{toCamelCase $tableName}}, error){
  cols := ""
  params:= ""
  vals := make([]any, 1)
  i := 1
  {{range $table.Columns}}
  if(!row.{{toCamelCase .ColumnName}}.isEmpty()){
    col := "{{.ColumnName}}"
    vals = append(vals, row.{{toCamelCase .ColumnName}}.get())
    if cols == "" {
      cols = col
      params = fmt.Sprintf("$%d", i)
      i++
    }else{
      cols = fmt.Sprintf("%s, %s", cols, col)
      params = fmt.Sprintf("%s, $%d", params, i)
      i++
    }
  }
  {{end}}
  query := fmt.Sprintf("INSERT INTO {{$tableName}} (%s) VALUES (%s) RETURNING *", cols, params)
  rawRow := db.QueryRow(ctx, query, vals[1:i]...)
  {{ range $table.Columns}} var {{ toCamelCase .ColumnName }} {{ .GetGoType }}
  {{end}}
  err := rawRow.Scan({{range $table.Columns}}&{{ toCamelCase .ColumnName}},{{end}})
  if err != nil{
    fmt.Printf("Error while inserting into {{$tableName}} row: %v \n error: %v\n", row, err)
    return nil, err
  }
  insertedRow := &{{toCamelCase $tableName}}{
    {{range $table.Columns}}{{ toCamelCase .ColumnName}}:some({{toCamelCase .ColumnName}}),{{end}}
  }
  return insertedRow ,nil
}

func Update{{toCamelCase $tableName}}(ctx context.Context, db DBTX, row {{toCamelCase $tableName}}) (bool, error) {
  setClause := ""
  whereClause := ""
  vals := make([]any, 1)
  i := 1
  {{range $table.Columns}}
  if(!row.{{toCamelCase .ColumnName}}.isEmpty()){
    col := "{{.ColumnName}}"
    vals = append(vals, row.{{toCamelCase .ColumnName}}.get())
    if i == 1 {
      setClause = fmt.Sprintf("%s %s = $%d", setClause, col, i)
    }else{
      setClause = fmt.Sprintf("%s, %s = $%d", setClause, col, i)
    }
    i++
  }
  {{end}}
  j := i
  col := ""
  {{range $table.PK}}
  col = "{{.ColumnName}}"
  vals = append(vals, row.{{toCamelCase .ColumnName}}.get())
  if i == j {
    whereClause = fmt.Sprintf("%s %s = $%d", whereClause, col, i)
  }else{
    whereClause = fmt.Sprintf("%s AND %s = $%d", whereClause, col, i)
  }
  i++
  {{end}}
  query := fmt.Sprintf("UPDATE {{$tableName}} SET %s WHERE %s", setClause, whereClause)
  _, err := db.Exec(ctx, query, vals[1:i]...)
  if err != nil {
    fmt.Printf("%v \n", err)
    return false, err
  }
  return true, nil
}

{{end}}

// test
func createDBConnection(connectionCount int32) *pgxpool.Pool {
	pgxConfig, err := pgxpool.ParseConfig("postgres://adisuper:adisuper@localhost:5432/turbo?sslmode=disable")
	if err != nil {
		panic(err)
	}
	pgxConfig.MaxConns = connectionCount
	conn, err := pgxpool.NewWithConfig(context.TODO(), pgxConfig)
	if err != nil {
		panic(err)
	}
	return conn
}

func main(){
  db := createDBConnection(1)
  msg := Messages{
    Body: some("test string"),
    Id: none[string](),
    ChatRoomId: some("e654227a-b11b-48c5-b249-a9e378f64b5f"),
    SenderId: some("arun"),
    CreatedAt: none[pgtype.Timestamptz](),
    ModifiedAt: none[pgtype.Timestamptz](),
  }
	rowp, err := InsertMessages(context.Background(), db, msg)
  if err != nil {
    fmt.Printf("%v", err)
  }
  fmt.Printf("Inserted row is %v\n\n", rowp)

  row, err:= GetMessagesByPK(context.Background(), db, rowp.Id.get())
  if err != nil {
    fmt.Printf("error while executing select query: %v\n\n", err)
    return
  }
  fmt.Printf("select inserted message : %v\n\n", row)

  msg = Messages{
    Id: rowp.Id,
    Body: some("test string after update"),
  }
  ok, err := UpdateMessages(context.Background(), db, msg)
  if err != nil {
    fmt.Printf("error while executing update query: %v\n\n", err)
    return
  }
  fmt.Printf("update successful :%v \n\n", ok)

  row, err= GetMessagesByPK(context.Background(), db, rowp.Id.get())
  if err != nil {
    fmt.Printf("error while executing select query: %v\n\n", err)
    return
  }
  fmt.Printf("select inserted message after update : %v\n\n", row)

  ok, err = DeleteMessagesByPK(context.Background(), db, rowp.Id.get())
  if err != nil {
    fmt.Printf("error while executing delete query: %v\n\n", err)
    return
  }
  fmt.Printf("delete successful :%v \n\n", ok)
  rows , err := SelectAllMessages(context.Background(), db)
  if err != nil {
    fmt.Printf("error : %v", err)
    return
  }
	fmt.Printf("select all message after delete : %v\n\n", rows)

}
